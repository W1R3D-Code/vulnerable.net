using Microsoft.AspNetCore.Mvc.Filters;
using System.Text;
using System.Text.RegularExpressions;
using Vulnerable.Common.Enums;

namespace Vulnerable.MVC.Filters;

[AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = false)]
public class ChallengeFilter : Attribute, IAsyncActionFilter
{
    private readonly string _challengeName;
    private readonly ChallengeCategory _challengeCategory;
    private readonly Regex _challengeRegex;

    public ChallengeFilter(string ChallengeName, ChallengeCategory challengeCategory, string challengeRegex)
    {
        if (string.IsNullOrEmpty(challengeRegex))
            throw new ArgumentNullException(nameof(challengeRegex));

        _challengeName = ChallengeName;
        _challengeCategory = challengeCategory;
        _challengeRegex = new Regex(challengeRegex, RegexOptions.IgnoreCase | RegexOptions.Multiline);
    }

    public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
    {
        await CheckChallenge(context.HttpContext.Request);
        await next();
    }

    //  TODO::  refactor autogenerated Razor Page handlers into controllers and apply filter via attribute
    public async Task CheckChallenge(HttpRequest request)
    {
        var method = request.Method;
        var contentType = request.ContentType;

        if (string.Equals(method, "GET", StringComparison.OrdinalIgnoreCase))
        {
            var query = request.Query;

            if (query != null && query.Any(x => _challengeRegex.IsMatch(x.Value)))
            {
                ChallengeCompleted();
            }
        }
        else if (string.Equals(method, "POST", StringComparison.OrdinalIgnoreCase) && (
            string.Equals(contentType, "application/x-www-form-urlencoded", StringComparison.OrdinalIgnoreCase) ||
            string.Equals(contentType, "application/json", StringComparison.OrdinalIgnoreCase)
            ))
        {
            //  Allow access to the request after we read it
            request.EnableBuffering();

            //  Leave request body stream open so it can still be read
            using var reader = new StreamReader(
                request.Body,
                encoding: Encoding.UTF8,
                detectEncodingFromByteOrderMarks: false,
                bufferSize: -1,
                leaveOpen: true);

            var body = await reader.ReadToEndAsync();

            if (body != null && _challengeRegex.IsMatch(body))
            {
                ChallengeCompleted();
            }

            // Reset the request body stream position
            request.Body.Position = 0;
        }
    }

    public void ChallengeCompleted()
    {
        //  TODO:: Handle challenge success
    }
}
